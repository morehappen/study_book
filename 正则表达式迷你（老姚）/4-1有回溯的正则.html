<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    //（1）有回溯的匹配
    var regex = /ab{1,3}bbc/;
    var str = regex.test('abbbc');
    //在匹配abbb,继续匹配abbbb时候无法满足，此时发生匹配回溯。
    console.log(str);//true
    //（2）贪婪量词和回溯的关系，{1,3}是贪婪量词
    //贪婪量词匹配的时候，只要可能就会匹配到3个；相反，惰性匹配到1个就会停止。
    //（3）惰性量词和回溯的关系，{1,3}？是惰性量词
    var string = '12345';
    var regex1 = /(\d{1,3}?)(\d{1,3})/;
    var regex2 = /^(\d{1,3}?)(\d{1,3})$/;
    console.log(string.match(regex1));// ["1234", "1", "234", index: 0, input: "12345"]
    console.log(string.match(regex2));// ["1234", "12", "345", index: 0, input: "12345"]
    //该匹配发生回溯，为了整体匹配成功，会无视惰性匹配的最低长度问题
    //（4）分支回溯问题
    var regexBranch = /^(?:can|candy)$/;
    var strBranch = 'candy';
    //第一个子分支can匹配成功，但是接下来会继续匹配该分支和整体，不成功，
    // 将切换其他分支进行匹配，这也是一种形式上的回溯。
</script>
</body>
</html>