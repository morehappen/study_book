<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。
    // 异步加载，依赖前置
    // 优点：
    // 1， 模块化， 遵循CommonJS理念， 一个文件即模块。
    // 2， 低耦合， 由于采用命名空间内作用域有效， 所有外部无法访问私有变量。
    // 3， 统一性， 都由全局变量define函数（ 导出） 定义模块， 全局变量require函数导入模块。
    // 4， 高效性， 由于采用的是异步加载的方式来加载模块， 加载方法和CommonJS“ 一样“， 都是使用require来加载模块。 但是AMD的require有点不一样， AMD的require导入模块时是异步的， 而且语法是： require([依赖1, 依赖2...], function() {})。 也就是说， 要先加载完所有依赖， 才执行回调函数， 而该回调回调函数的参数， 也必须严格按照数组内的模块顺序来作为参数， 回调函数内都是依赖于这些模块的逻辑代码。 那些和这些依赖无关的， 可以写在外面， 在加载依赖时， 是不会影响接下来的代码的。 这也就对应了： 异步加载， 是不会影响后面的代码的运行的。
    // 缺点：
    // 1， 关系前置， 我个人称为“ 依赖前置“。 可能由于设计思想的原因， AMD虽说是异步加载模块， 但却是一次性加载完了对应模块， 再执行回调。 虽说没毛病， 我只有等我需要的装备都齐了， 才能打boss， 这也说的过去。 但是从人性化来看， 就不怎么好了， 我希望我想加载哪个的时候， 再加载， 不想加载的时候， 你就别动。 这点可以查看下面CMD的优点。
    // 2， 写法比较轻浮， 光是定义模块就有好几种写法（ 虽说官网有推荐写法-- - 定义模块）。 但这对初学者的我， 会产生很多疑惑， 也浪费了很多比较的时间。


    // 它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。

    // AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：
    require([module], callback);
    // 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：
    require(['math'], function(math) {

        　　　　
        math.add(2, 3);

        　　
    });
    // math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。
</script>

</html>